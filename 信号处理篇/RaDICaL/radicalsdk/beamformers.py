# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06_beamformers.ipynb (unless otherwise specified).

__all__ = ['cov_matrix', 'forward_backward_avg', 'aoa_capon']

# Cell
import tensorflow as tf
import tensorflow.linalg as linalg

# Cell
def cov_matrix(x):
    """Computes the covariance matrix $R_{xx}$ on signal `x`

    $$ R_{xx} = xx^H $$

    `x` can be batched. Hermitian transpose and matrix multiply applied on the last 2 dimensions

    """
    n_chirps = x.shape[-1]
    Rxx = tf.matmul(x, x, adjoint_b=True)
    return Rxx/n_chirps

def forward_backward_avg(Rxx):
    """Forward-Backward Averaging of covariance matrix `Rxx`

    > M. Zatman and D. Marshall, "Forward-backward averaging in the presence of array manifold errors,"
    > in IEEE Transactions on Antennas and Propagation, vol. 46, no. 11, pp. 1700-1704, Nov. 1998, doi: 10.1109/8.736625.

    Inputs:
     - Rxx: Batch of covariance matrices `[N, m, m]`

    """
    num_rx = Rxx.shape[-1]

    J = tf.reverse(tf.eye(num_rx, dtype=Rxx.dtype), [-1])

    R_fb = 0.5 * (Rxx + tf.matmul(
        J, tf.matmul(tf.math.conj(Rxx), J)))

    return R_fb

def aoa_capon(x, steering_vec, mu = 1e-7):
    """Tensorflow implementation of Capon AoA estimatation

    Inputs:
    - `x`: signal to be beamformed. `[N, n_rx, n_samples]`
    - `steering_vec`: Vandermode steering vector [n_angle_bins, n_rx]
    - `mu`: detuning factor, if $R_{xx}$ is singular, ensures that `linalg.inv` gives stable results.


    Outputs:
    - `den`: denominator of Capon beamforming equation, i.e. $a(\\theta)^*R_{xx}^{-1}a(\\theta)^T$
    - `weights`: tuning weights for each antenna
    """
    num_rx = x.shape[-2]
    Rxx = cov_matrix(x)
    Rxx = forward_backward_avg(Rxx)

    if mu is not None:
        uI = tf.eye(num_rx, dtype=x.dtype) * mu
        Rxx_inv = linalg.inv(Rxx+uI)
    else:
        Rxx_inv = linalg.inv(Rxx)
    Rxx_inv_a = tf.matmul(Rxx_inv, steering_vec, transpose_b=True)

    den = tf.math.reciprocal_no_nan(
        tf.einsum('ij,...ji->...i', tf.math.conj(steering_vec), Rxx_inv_a)
    )
    weights = tf.einsum('bij,bj->bi', Rxx_inv_a, den)

    return den, weights